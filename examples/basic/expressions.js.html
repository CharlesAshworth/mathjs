<!DOCTYPE html>
<html>
  <head></head>
  <body>
    <h3 style="text-align: center">MathJS Basic Examples</h3>

    <script src="https://embed.runkit.com"></script>
    <div id="my-element"></div>
    <script>
      var notebook = RunKit.createNotebook({
        // the parent element for the new notebook
        element: document.getElementById('my-element'),
        // specify the source of the notebook
        source:
          "/** * Expressions can be evaluated in various ways:\n* \n* 1. using the function math.evaluate\n* 2. using the function math.parse\n* 3. using a parser. A parser contains functions evaluate and parse,\n*    and keeps a scope with assigned variables in memory\n*/\n// load math.js (using node.js)\nconst math = require('..')\n// 1. using the function math.evaluate\n//\n// Function `evaluate` accepts a single expression or an array with\n// expressions as first argument, and has an optional second argument\n// containing a scope with variables and functions. The scope is a regular\n// JavaScript Object. The scope will be used to resolve symbols, and to write\n// assigned variables or function.\nconsole.log('1. USING FUNCTION MATH.EVAL')\n// evaluate expressions\nconsole.log('\nevaluate expressions')\nprint(math.evaluate('sqrt(3^2 + 4^2)')) // 5\nprint(math.evaluate('sqrt(-4)')) // 2i\nprint(math.evaluate('2 inch to cm')) // 5.08 cm\nprint(math.evaluate('cos(45 deg)')) // 0.70711\n// evaluate multiple expressions at once\nconsole.log('\nevaluate multiple expressions at once')\nprint(math.evaluate([  'f = 3', 'g = 4', 'f * g'])) // [3, 4, 12]\n// provide a scope (just a regular JavaScript Object)\nconsole.log('\nevaluate expressions providing a scope with variables and functions')\nconst scope = {a: 3,b: 4}\n// variables can be read from the scope\nprint(math.evaluate('a * b', scope)) // 12\n// variable assignments are written to the scope\nprint(math.evaluate('c = 2.3 + 4.5', scope)) // 6.8\nprint(scope.c) // 6.8\n// scope can contain both variables and functions\nscope.hello = function (name) {\n  return 'hello, ' + name + '!'} \nprint(math.evaluate('hello(\"hero\")', scope)) \n//\"hello, hero!\"\n// define a function as an expression\nconst f = math.evaluate('f(x) = x ^ a', scope)\nprint(f(2)) // 8\nprint(scope.f(2)) // 8\n// 2. using function math.parse\n//\n// Function `math.parse` parses expressions into a node tree. The syntax is\n// similar to function `math.evaluate`.\n// Function `parse` accepts a single expression or an array with\n// expressions as first argument. The function returns a node tree, which\n// then can be compiled against math, and then evaluated against an (optional\n// scope. This scope is a regular JavaScript Object. The scope will be used\n// to resolve symbols, and to write assigned variables or function.\nconsole.log('\n2. USING FUNCTION MATH.PARSE') \n// parse an expression  \nconsole.log('\nparse an expression into a node tree') \nconst node1 = math.parse('sqrt(3^2 + 4^2)') \nprint(node1.toString()) // \"sqrt((3 ^ 2) + (4 ^ 2))\" \n// compile and evaluate the compiled code\n// you could also do this in two steps: node1.compile().evaluate()\nprint(node1.evaluate()) // 5 \n// provide a scope  \nconsole.log('\nprovide a scope') \nconst node2 = math.parse('x^a') \nconst code2 = node2.compile() \nprint(node2.toString()) // \"x ^ a\" \nconst scope2 = { \n  x: 3,   \n  a: 2 \n} \nprint(code2.evaluate(scope2)) // 9  \n// change a value in the scope and re-evaluate the node \nscope2.a = 3 \nprint(code2.evaluate(scope2)) // 27 \n// 3. using function math.compile  \n//  \n// Function `math.compile` compiles expressions into a node tree. The syntax is \n// similar to function `math.evaluate`. \n// Function `compile` accepts a single expression or an array with \n// expressions as first argument, and returns an object with a function evaluate \n// to evaluate the compiled expression. On evaluation, an optional scope can \n// be provided. This scope will be used to resolve symbols, and to write \n// assigned variables or function. \nconsole.log('\n3. USING FUNCTION MATH.COMPILE')\n// parse an expression \nconsole.log('\ncompile an expression') \nconst code3 = math.compile('sqrt(3^2 + 4^2)')\n// evaluate the compiled code\nprint(code3.evaluate()) // 5\n// provide a scope for the variable assignment \nconsole.log('\nprovide a scope') \nconst code4 = math.compile('a = a + 3') \nconst scope3 = {     a: 7   }\ncode4.evaluate(scope3)\nprint(scope3.a) // 10\n// 4. using a parser\n//\n// In addition to the static functions `math.evaluate` and `math.parse`, math.js\n// contains a parser with functions `evaluate` and `parse`, which automatically\n// keeps a scope with assigned variables in memory. The parser also contains\n// some convenience methods to get, set, and remove variables from memory.\nconsole.log('\n4. USING A PARSER')\nconst parser = math.parser()\n// evaluate with parser\nconsole.log('\nevaluate expressions')\nprint(parser.evaluate('sqrt(3^2 + 4^2)')) // 5\nprint(parser.evaluate('sqrt(-4)')) // 2i\nprint(parser.evaluate('2 inch to cm')) // 5.08 cm\nprint(parser.evaluate('cos(45 deg)')) // 0.70710678118655\n// define variables and functions\nconsole.log('\ndefine variables and functions')\nprint(parser.evaluate('x = 7 / 2')) // 3.5\nprint(parser.evaluate('x + 3')) // 6.5 \nprint(parser.evaluate('f2(x, y) = x^y')) // f2(x, y) \nprint(parser.evaluate('f2(2, 3)')) // 8\n// manipulate matrices\n// Note that matrix indexes in the expression parser are one-based with the\n// upper-bound included. On a JavaScript level however, math.js uses zero-based\n// indexes with an excluded upper-bound.\nconsole.log('\nmanipulate matrices')\nprint(parser.evaluate('k = [1, 2; 3, 4]')) // [[1, 2], [3, 4]]\nprint(parser.evaluate('l = zeros(2, 2)')) // [[0, 0], [0, 0]]\nprint(parser.evaluate('l[1, 1:2] = [5, 6]')) // [5, 6]\nprint(parser.evaluate('l')) // [[5, 6], [0, 0]]\nprint(parser.evaluate('l[2, :] = [7, 8]')) // [7, 8]\nprint(parser.evaluate('l')) // [[5, 6], [7, 8]]\nprint(parser.evaluate('m = k * l')) // [[19, 22], [43, 50]]\nprint(parser.evaluate('n = m[2, 1]')) // 43\nprint(parser.evaluate('n = m[:, 1]')) // [[19], [43]]\n// get and set variables and functions\nconsole.log('\nget and set variables and function in the scope of the parser')\nconst x = parser.get('x')\nconsole.log('x =', x) // x = 3.5\nconst f2 = parser.get('f2')\nconsole.log('f2 =', math.format(f2)) // f2 = f2(x, y)\nconst h = f2(3, 3)\nconsole.log('h =', h) // h = 27\nparser.set('i', 500)\nprint(parser.evaluate('i / 2')) // 250\nparser.set('hello', function (name) {\n  return 'hello, ' + name + '!' \n}) \nprint(parser.evaluate('hello(\"hero\")')) // \"hello, hero!\" \n// clear defined functions and variables \nparser.clear() /n/**       /n* Helper function to output a value in the console. Value will be formatted./n* @param {*} value/n*//nfunction print (value) {/n  const precision = 14 /n  console.log(math.format(value, precision)) /n}",
      })
    </script>
  </body>
</html>
<!DOCTYPE html>
